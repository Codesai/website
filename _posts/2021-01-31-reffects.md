---
layout: post
title: reffects
date: 2021-01-31 06:00:00.000000000 +00:00
type: post
published: true
status: publish
categories:
- Effects and Coeffects
- Functional Programming
- Functional Reactive Programming
- Open Source
- reffects
- Learning
- Testing
tags: []
author: Manuel Rivero & Rubén Díaz
small_image: 
written_in: english
---

## History & Context

### Why reffects?

#### Trovit B2B in January 2019

* Backbone JS
* No testing by default
* A few components in React (only view code) with examples of testing supported by only one person
* Difficulties to attract and retain talent

#### B2B in March 2018

* Strategic goal: Move to React to attract talent
  * Problem: How do we manage state?
* Strategic goal: Improve technical practices
* Problem: it takes time
* Pressure: fusion with MiTula
* Pressure: team growth
* Pressure: mostly backend developers

#### Previous successful experiences

1. SPA with native and browser versions 
  * re-frame’s functional architecture removing a lot of accidental complexity
  * Super easy to test & develop
  * Reusing most of the code between native and browser versions (dumb views)
  * Subcutaneous testing

2. Legacy SPA using Om & imperative style
  * Super hard to test & develop
  * No testing culture
  * Strong resistance against testing
  * Rescued using functional architecture (re-om) to strangle the SPA
    * Huge increase in testing adoption

#### Decisions

1. Given the pressures and the strategic goals I wanted to to reduce the barrier to testing adoption.

2. I had experienced that a functional architecture based in effects & coeffects was really good in both greenfield & legacy scenarios

3. There were two new developers with a lot of experience in frontend with React, redux and redux sagas
4. Manuel Tordesillas might come to the team
5. In feedback to my talks I learned that we might get what we wanted with redux sagas + reselect

6. Taking advantage of the "confusion" at the beginning of the fusion we did a spike with redux sagas + reselect
  * redux sagas: resulting tests were too low level + generators were complex
  * reselect was great

7. So I decided to try and write a port of re-om to JS with Mario and Alex -> reffects

### Why a functional architecture?

* No es una técnica para producir mejor código sino que es una técnica para producir más valor más rápido, el buen código es un medio no un objetivo en sí mismo.

* We’re in this for the money! Shipping more value faster

* How does good design look like?

* Any design imposes constraints on how we can change the code (even the lack of it) 

* A good design must support evolution

* To change a code base with confidence at a sustainable pace, you require tests

* A good design must be testable

* What about pure functions?

* Pure functions advantages

    * Local Reasoning

    * Great testability

* But side-effects are inevitable...

* What’s the problem with effectful code?

* Effectful functions problems

  * Action at a distance

  * Difficult to test

* How do we usually try to fix this?

  * Separation of concerns & test doubles


  * This way we regain isolation and testability


* Accidental complexity!

* Is there a better way?

* Functional architectures help you maximize the ratio of pure code vs effectful code


* Functional  architectures are highly testable

  * The testing potential barrier will be very low in most of the code

* And they are easier to test

* No need for test doubles in most of the code

* Each type of side-effect can be tested once and only once

* A Pit of Success

> “A well-designed system makes it easy to do the right things and annoying (but not impossible) to do the wrong things.” 
> Jeff Atwood

* Functional core, Imperative Shell

* Frontend development might be quite difficult

Asynchrony
DOM manipulation        
Local state
Interacting with the browser APIs
....


Reffects functional architecture can reduce those pains


Event-driven Unidirectional Flow

All state management logic is contained in event handlers (pure functions)

All event handlers are pure functions

But side-effects are inevitable...

How can event handlers be pure?

Thanks to the declarative effects or effects as data pattern

Types of side-effects

What an effectful function changes in the world -> a kind of output that we’ll call side-effect

What an effectful function gets from the world without receiving it through its parameters -> a kind of input that we’ll call side-cause

Effects and Coeffects

Effects: describe your program’s side-effects (what it does to the world)

Coeffects: track your program’s side-causes (what it requires from the world)

Declarative Effects pattern

Event handlers are pure functions

They receive coeffects and return effects

Injecting the values coeffects track and interpreting effects to actually perform side-effects are done by sth else (a language run-time, a framework, etc)


IDEA: Reffects es el que habilita que estos efectos y coefectos como datos sean interpretados por los effect handlers y coeffect handlers.

By applying this pattern, reffects maximizes the ratio of pure code vs effectful code

Pure code vs effectful code (pie chart)

Functional core, Imperative Shell

Advantages over ports & adapters

Less accidental complexity in business logic

Remove business logic fragility to interface changes in ports

Still keeps pluggability (you can still use ports & adapters in the imperative shell)

Each type of side-effect is tested once and only once (in its effect or coeffect handler)


reffects provides functions to register your event, effect and coeffect handlers

It also provides built-in effect and coeffect handlers in its “batteries”


What about the views?

Selectors

Selectors are pure functions that extract data from the state and provide it to view functions the way they need

Subscriptions

We subscribe components to the pieces of the state they are interested in, so that those components react when that piece of state changes (they basically rerender).

Selectors are what tells a subscription what piece of state is going to be tracked.

Simpler state & Dumber Views

Avoid keeping derived state in the store.

Dumb down the views, that end up being simple “data in, screen out” functions

Subscriptions optimize views by removing unnecessary renderings

This is ideal for applying subcutaneous testing

Subcutaneous testing strategy

We choose not to test UI components because they are dumb simple “data in, screen out” functions

Warning: subcutaneous testing requires keeping all useful logic out of your UI. If you don’t follow this advice, using subcutaneous testing will leave important behavior untested

More optimization using reselect

reselect is a simple “selector” library for Redux (and others) inspired by re-frame’s subscriptions

reselect’s selectors are efficient: a selector is not recomputed unless one of its arguments changes

reselect’s selectors are composable: they can be used as input to other selectors

